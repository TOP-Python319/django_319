# Django_319 - Учебный проект "Карточки интервального повторения"
## Lesson 45

### Создали проект Django_319

1. Создали репозиторий
2. Создали проект Django_319
3. Установили зависимости `pip install django==4.2`
4. Сохранили зависимости в файл `reqirements.txt` командой `pip freeze > requirements.txt`

Развернуть проект на локальной машине:
 - Склонировать репозиторий командой `git clone git@github.com:TOP-Python319/django_319.git`
 - Перейти в папку проекта `cd django_319`
 - Создать виртуальное окружение `python -m venv venv`
 - Активировать виртуальное окружение `source venv/bin/activate` на Linux/MacOS или `.\venv\Scripts\activate.bat` на Windows
 - Установить зависимости `pip install -r requirements.txt`

### Создание Django project

1. Создать проект `django-admin startproject anki .`
Этой командой мы создадим проект с именем `anki` в текущей директории.
Точка в конце команды означает, что проект будет создан в текущей директории, 
без создания дополнительной директории с именем проекта.

**commit: `lesson_45: создаём django проект`**

2. Запуск проекта `python manage.py runserver`
Для запуска проекта, вам нужно использовать терминал, и находясь в директории проекта, на одном уровне с файлом `manage.py`, выполнить команду `python manage.py runserver`
Для остановки сервера используйте комбинацию клавиш `Ctrl+C`

**Команды терминала:**
- `python manage.py runserver` - запуск сервера
- `cd` - смена директории
- `cd..` - переход на уровень выше
- `ls` - просмотр содержимого директории
- `pwd` - показать текущую директорию

**commit: `lesson_45: запускаем django сервер`**

3. Создание приложения `python manage.py startapp cards`
После создания приложения, вам нужно зарегистрировать его в файле `settings.py` в разделе `INSTALLED_APPS`

**commit: `lesson_45: cоздаём django_app cards`**

### Создали первое представление

```python
from django.http import HttpResponse

def main(request):
    return HttpResponse("Hello, world!")  # вернет страничку с надписью "Hello, world!"

```

Чтобы представление заработало, его нужно зарегистрировать в файле `urls.py` конфигурации проекта.

### Создали первый URL

```python
path('', views.main),
```

Теперь, если вы перейдете на главную страницу сайта, то увидите надпись "Hello, world!"

**commit: `lesson_45: создаём первый маршрут и первое представление`**


## Lesson 46

### Создаем детальное представление карточки по ее ID

Для этого нам нужно создать новый маршрут, с конвертом int, который будет принимать ID карточки.

```python
path('cards/<int:card_id>/', views.card_detail),
```

А так же функцию, которая будет обрабатывать запрос и возвращать страницу с детальной информацией о карточке.

```python
def card_by_id(request, card_id):
    return HttpResponse(f"Карточка с ID {card_id}")
```

### `include` и собственный файл `urls.py` для приложения `cards`

1. Создали еще одно представление `get_all_cards` в файле `views.py`
2. Создали файл `urls.py` в директории приложения `cards`
3. Зарегистрировали новый файл `urls.py` в файле `urls.py` конфигурации проекта с помощью функции `include`
4. Зарегистрировали маршруты без префикса `cards/` в файле `urls.py` приложения `cards`
5. Удалили маршруты `cards/` из файла `urls.py` конфигурации проекта

**commit: `lesson_46: собственный urls.py в cards и функция include`**

### Знакомство с Django Templates (Шаблоны)

1. Создали папку `templates` в директории приложения `cards`
2. Создали файл `catalog.html` в директории `templates/cards`
3. Переписали функцию `get_all_cards` в файле `views.py` так, чтобы она возвращала страницу `catalog.html`
используя функцию `render` из модуля `django.shortcuts`

**commit: `lesson_46: рендер первого шаблона`**

### Работа с шаблоном 
1. Создали словарь с данными в `views.py` и передали его в шаблон
```python
info = {
    "users_count": 100600,
    "cards_count": 100600,
}
```
2. Вставили данные в шаблон `catalog.html` с помощью шаблонного языка Django
3. Подключили BS5 по CDN и стилизовали страницу

**commit: `lesson_46: передал первые данные в шаблон и подключил BS5`**

### Смотрим типы данных внутри шаблона
- Проверили, что можем передать экземпляр класса, и вывести его атрибуты в шаблоне
- Проверили, что можно передать только словарь
- Передали список и вывели его в шаблоне
- Передали список меню и познакомились с конструкцией `{% for item in menu %}`

**commit: `lesson_46: первый цикл в шаблоне`**

### Посмотрели на тег шаблона `if`
- Сделали `<hr>` после каждого элемента списка, кроме последнего

**commit: `lesson_46: первый тег if в шаблоне`**

### Сделали ссылки в меню кликабельными
- Передали в шаблон список словарей, где каждый словарь содержит url и title
- Осталось протестировать шаблонный тег `url`!

**commit: `lesson_46: сделал ссылки в меню кликабельными`**


## Lesson 47

### Сделали практику
- Описали маршруты 
  /catalog,
  /catalog/<int:card_id/>,
  /catalog/<slug:slug>
  и создали соответствующие представления в файле views.py
- catalog возвращает HttpResponse("Каталог карточек")
- get_card_by_id возвращает HttpResponse(f"Карточка {card_id}")
- get_category_by_name возвращает HttpResponse(f"Карточка {slug}")

Определили, что важнейшую роль играет порядок подключения URL-маршрутов в файле `urls.py`,
отрабатывает первый попавшийся маршрут.

Если первый `slug` - то он отработает и число и строку.
Если первый `int` - то он будет отрабатывать число, а `slug` будет отрабатывать строку.

**commit: `lesson_47: добавили новые маршруты`**

### Изменение структуры `cards/url.py` и `cards/views.py`
Изменил пути и функции для дальнейшего развития проекта.

**commit: `lesson_47: изменение структуры путей`**

### Создание базового шаблона `base.html` в корне проекта в папке `templates`
- Создали базовый шаблон `base.html` в папке `templates`
- Указали кастомный, нестандартный путь для Джанго в файле `settings.py` в разделе `TEMPLATES` 
- Прописали там `BASE_DIR / 'templates',`
- Подключили базовый шаблон для теста функции `main` в файле `views.py`

**commit: `lesson_47: создали базовый шаблон base.html`**

### Синтаксис блоков в шаблонах. `{% block %}` и `{% extends %}`

- Описали блок `content` в базовом шаблоне `base.html`
- Создали шаблон `main.html` в папке `templates`, который расширяет базовый шаблон `base.html` через `{% extends %}`
- Переопределили блок `content` в шаблоне `main.html` через `{% block %}`
- Переопределили блок `footer` в шаблоне `main.html` через `{% block %}`
- Подключили шаблон `main.html` в функции `main` в файле `views.py`

**commit: `lesson_47: создали шаблон main.html и расширили базовый шаблон`**

### Создание шаблона `nav_menu.html` и подключение его в базовом шаблоне через `{% include %}`
- Создали каталог `includes` в папке `templates` в корне проекта
- Создали шаблон `nav_menu.html` в папке `includes`
- Написли навигационное меню в шаблоне `nav_menu.html`
- Использовали шаблонный тег `{% url %}` который позволяет создавать ссылки на страницы по их именам в файле `urls.py`
- Подключили шаблон `nav_menu.html` в базовом шаблоне `base.html` через `{% include %}`
- Добавили датасет с карточками и меню, чтобы проверить работу шаблона

**commit: `lesson_47: создали шаблон nav_menu.html и подключили его в базовом шаблоне`**


## Lesson 48

### Работа с шаблонами `about.html`, `catalog.html`, `main.html` а так же модификация `views.py`
- Модифицировали все шаблоны, и сделали так, чтобы они наследовались от базового шаблона
- Модфицировали соответствующие функции в файле `views.py`, чтобы они возвращали нужные шаблоны и принимали данные для меню
- Наладили рендер меню во всех шаблонах, и получили "сквозное" меню на всех страницах

**commit: `lesson_48: модифицировали все шаблоны и функции в views.py — сквозная навигация`**

### Начали работу над каталогом карточек (динамическая вставка данных в шаблон, цикл + `include`)
- Создали `include` в папке `templates` в приложении `cards`
- Внутри создали шаблон `card_preview.html`
- Шаблон `card_preview.html` принимает на вход словарь с данными о карточке и возвращает карточку,
которая будет вставлена в каталог карточек в шаблоне `catalog.html` в цикле

**commit: `lesson_48: начали работу над каталогом карточек и динамической вставкой данных в шаблон`**

### Продолжили работу над каталогом карточек (динамическая вставка данных в шаблон, цикл + `include`)
- Добавили шаблон `card_detail.html` в папке `templates/cards` 
- Доделали `include` в шаблоне `catalog.html` и вставили в него карточки из словаря
- Обновили функцию `get_detail_card_by_id` - сделали поиск карточки по ID в словаре и возврат шаблона `card_detail.html` ИЛИ `404`

**commit: `lesson_48: доделали каталог карточек и детальное отображение карточки по ID`**

### Собственные шаблонные теги через `simple_tag`
- Создали тег шаблона `markdown_to_html` через `simple_tag` в файле `cards/templatetags/markdown_to_html.py`
- Протестировали его в представлении `card_detail` в шаблоне `card_detail.html`
- После создания тега и регистрации с помощью `template.Library()` нужно перезапустить сервер

**commit: `lesson_48: создал собственный тег шаблона markdown_to_html через simple_tag`**

### Создали папку `static` в приложении `cards` и подключили статику в шаблоне `base.html`
- Создали папку `static` в приложении `cards`
- Создали папку `cards` в папке `static`
- В ней создали папку `css` и файл `main.css`, а так же папку `js` и файл `main.js`
- Создали тестовые стили и скрипт
- Подключили статику в шаблоне `base.html` через тег `{% load static %}` и тег `{% static %}`
- Подключили стили и скрипт в шаблоне `base.html`
- Проверили работу статики на всех страницах
- После создания и подключения статики нужно перезапустить сервер

**commit: `lesson_48: подключили статику в шаблоне base.html`**

### Работа с фильтрами в шаблонах
Посмотрели на работу следующих фильтров в шаблоне `card_preview.html`:
- `length`
- `truncatechars`
- `join`

Так же, в шаблон был добавлен цикл для вывода тегов карточки.

**commit: `lesson_48: работа с фильтрами в шаблонах`**


## Lesson 49

### Выполнили служебные миграции
- Посмотрели список миграций с помощью команды `python manage.py showmigrations`

- Посмотрели какой SQL-код выполнялся с помощью команды `python manage.py sqlmigrate admin 0001` для приложения `admin`, миграции с номером `0001`

- Выполнили миграции командой `python manage.py migrate`
Это создало служебные таблицы в базе данных, которые используются для работы с пользователями, сессиями, административной панелью и т.д.

- Создали суперпользователя (админа) командой `python manage.py createsuperuser`

- Проверили, что административная панель заработала по адресу `http://127.0.0.1:8000/admin/`

**commit: `lesson_49: применили первые миграции и создали админа`**

### Сделали первую модель `Card` и миграции к ней

- Создали миграцию командой `python manage.py makemigrations`
- Применили миграции командой `python manage.py migrate`
- Проверили вручную, что таблица `Cards` действительно создалась

**commit: `lesson_49: создали первую модель`**

### Знакомство с `Shell Plus` и работа с моделью `Card` в интерактивной оболочке Django
- Установка `Shell Plus` командой `pip install django-extensions`
- Добавление `django_extensions` в `INSTALLED_APPS` в файле `settings.py`
- Запуск `Shell Plus` командой `python manage.py shell_plus` (для отображения SQL запросов в консоли - `python manage.py shell_plus --print-sql`)

**commit: `lesson_49: установка Shell Plus и подготовка ORM`**

### CRUD Операции с моделью Card

1. Добавление данных
```python
card = Card.objects.create(
    question='Python or perl?',
    answer='Python',
)
card.save()
```
```python
card = Card.objects.create(
    question='Python or ruby?',
    answer='Python',
)
card.save()
```
2. Чтение данных
```python
# get - получение данных, но только одной записи
card = Card.objects.get(id=1)
card = Card.objects.get(pk=1)  # pk отличается от id, тем что pk ссылается на первичный ключ (в таблице) вне зависимости от его названия
card = Card.objects.get(question='Python or ruby?')

card = Card.objects.get(answer='Python')  # если несколько записей, то выдаст ошибку
```
```python
# all - получение всех данных
cards = Card.objects.all()  # получение всех карточек в виде итерируемого объекта

for card in Card.objects.all():
    print(card.question)
```

3. Обновление данных
```python
card = Card.objects.get(pk=1)
card.question = 'Python or PHP?'
card.save()
```

4. Удаление данных
```python
card = Card.objects.get(pk=1)
card.delete()
```

**commit: `lesson_49: базовые CRUD Операции с моделью Card`**

### Подключение модели `Card` в административной панели
- Создали файл `admin.py` в приложении `cards` (если его нет)
- Зарегистрировали модель `Card` в административной панели
- `settings.py` `LANGUAGE_CODE = 'ru-ru'` - для русского языка в админке

```python
from django.contrib import admin
from .models import Card

class CardAdmin(admin.ModelAdmin):
    pass

admin.site.register(Card, CardAdmin)
```

- создаем суперпользователя если он ещё не был создан `python manage.py createsuperuser`
- 
**commit: `lesson_49: подключили модель Card в административной панели`**

### Методы объектного менеджера `objects`
- `all()` - возвращает все объекты модели
- `filter()` - возвращает объекты, которые соответствуют условиям фильтрации
- `get()` - возвращает объект, который соответствует условиям фильтрации
- `exclude()` - возвращает объекты, которые НЕ соответствуют условиям фильтрации
- `order_by()` - возвращает объекты, отсортированные по указанному полю
- `first()` - возвращает первый объект из выборки
- `last()` - возвращает последний объект из выборки
- `count()` - возвращает количество объектов в выборке
- `exists()` - возвращает True, если хотя бы один объект соответствует условиям фильтрации
- `delete()` - удаляет объекты, которые соответствуют условиям фильтрации
- `update()` - обновляет объекты, которые соответствуют условиям фильтрации
  
Lookups кратко:
1. Получим карточки, где вопрос содержит Python
```python
Card.objects.filter(question__contains='Python')
```
2. Получим карточки, где просмотров больше 9
```python
Card.objects.filter(views__gt=9)
```
3. Получим карточки, где просмотров меньше или равно 9
```python
Card.objects.filter(views__lte=9)
```
4. Получим карточки, где просмотров НЕ меньше или равно 9
```python
Card.objects.exclude(views__lte=9)
```
5. Посчитаем количество карточек, где просмотров НЕ меньше или равно 9
```python
Card.objects.exclude(views__lte=9).count()
```

**commit: `lesson_49: методы объектного менеджера objects`**

добавили новые маршруты, добавили стили и иконки, добавили адаптивность

**commit: `lesson_49: сделали симпатичную вёрстку`**


## Lesson 50

### Сделаем чтение из БД в каталоге карточек
- В файле `views.py` в функции `catalog` изменили возврат словаря на возврат списка карточек из БД
- В файле-вставке `include/card_preview.html` изменили вставку данных id карточки на `card.id` (что соответствует полю id в БД)

**commit: `lesson_50: сделали чтение из БД в каталоге карточек`**

### Сделаем детальное отображение карточки из БД по ID
- В файле `views.py` в функции `get_detail_card_by_id` изменили возврат словаря на возврат карточки из БД
- В файлах `card_detail.html`, `card_preview.html` изменили вставку данных просмотров и добавления в избранное на `card.views` и `card.adds` (что соответствует полям views и adds в БД)

**commit: `lesson_50: сделал детальное отображение карточки из БД по ID`**

- добавил примеры для настройки отображения админки в `cards/admin.py`

**commit: `lesson_50: добавил примеры для настройки отображения админки`**

### Добавили теги в модель `Card`
- Добавили поле `tags` в модель `Card`
- Создали миграцию командой `python manage.py makemigrations`
- Применили миграцию командой `python manage.py migrate`

**commit: `lesson_50: добавили теги в модель Card`**

### Сортировка для каталога 

- **`sort`** - ключ для указания типа сортировки с возможными значениями: `upload_date`, `views`, `adds`.
- **`order`** - опциональный ключ для указания направления сортировки с возможными значениями: `asc`, `desc`. По умолчанию `desc`.

#### Примеры URL-запросов
1. Сортировка по дате добавления в убывающем порядке (по умолчанию): `/cards/catalog/`
2. Сортировка по количеству просмотров в убывающем порядке: `/cards/catalog/?sort=views`
3. Сортировка по количеству добавлений в возрастающем порядке: `/cards/catalog/?sort=adds&order=asc`
4. Сортировка по дате добавления в возрастающем порядке: `/cards/catalog/?sort=upload_date&order=asc`

**commit: `lesson_50: сделали сортировку для каталога`**

### `get_object_or_404` для детального отображения карточки по ID

**commit: `lesson_50: get_object_or_404 для детального отображения карточки по ID`**

### В общих чертах разобрали `F` объекты
- Для `get_detail_card_by_id` сделали увеличение просмотров на + 1 через `F` объект

**commit: `lesson_50: F объект для увеличения просмотров карточки`**


## Lesson 51

### Подготовили базу данных anki_final.db
```sql
PRAGMA foreign_keys = 0;

--Создание временной таблицы без столбца UserID
CREATE TABLE sqlitestudio_temp_table AS SELECT CardID, Question, Answer, CategoryID, UploadDate, Views, Favorites FROM Cards;

--Удаление оригинальной таблицы Cards
DROP TABLE Cards;

--Создание новой таблицы Cards без столбца UserID
 CREATE TABLE Cards (
 CardID INTEGER PRIMARY KEY AUTOINCREMENT,
 Question TEXT NOT NULL,
 Answer TEXT NOT NULL,
 CategoryID INTEGER,
 UploadDate DATETIME DEFAULT (datetime('now')),
 Views INTEGER DEFAULT (0),
 Favorites INTEGER DEFAULT (0),
 FOREIGN KEY (CategoryID) REFERENCES Categories (CategoryID) ON DELETE SET NULL ON UPDATE CASCADE
);

--Копирование данных обратно в Cards из временной таблицы
INSERT INTO Cards (CardID, Question, Answer, CategoryID, UploadDate, Views, Favorites)
SELECT CardID, Question, Answer, CategoryID, UploadDate, Views, Favorites FROM sqlitestudio_temp_table;

--Удаление временной таблицы
DROP TABLE sqlitestudio_temp_table;

PRAGMA foreign_keys = 1;
```

### написали новые модели
- описали модель Tag
- описали модель CardTag
- описали модель Category

### сделали миграцию
- старые миграции удалены
- заново применены 18 базовых миграции
- сделана фейковая миграция `python manage.py migrate --fake` для того чтобы 
Django "думал", что он сам создал наши новые таблицы

**commit: `lesson_51: подключили базу данных anki_final.db`**

- переписали шаблоны под изменившуюся логику модели Tag

**commit: `lesson_51: поправили код шаблонов карточек для отображения из БД`**

- установили библиотеку `markdown`
- написали функцию конвертации `MarkDown` в `HTML`
- подключили шаблонный тэг `markdown_to_html` в детальное представление карточки
- подключили шаблонный тэг `markdown_to_html` в отображение каталога карточек
- подключили `Highlight.js` для подсветки синтаксиса

**commit: `lesson_51: добавили конвертацию MD в HTML и подсветку кода`**

- добавили маршрут `tags/<int:tag_id>/` для отображения карточек по конкретному тэгу
- написали представление `get_cards_by_tag`
- поменяли шаблоны `card_detail.html` и `card_preview.html` для добавления кликабельности тэгам

**commit: `lesson_51: добавили кликабельные тэги`**


## Lesson 52

- установили отладочную панель Django (`pip install django-debug-toolbar==4.0.0`) и настроили её
- убедились в том, что наше приложение генерирует слишком много запросов

**commit: `lesson_52: установили отладочную панель Django`**

- включили жадную загрузку и снизили количество запросов до 4

**commit: `lesson_52: включили жадную загрузку`**

- включили кэширование данных

**commit: `lesson_52: включили кэширование`**

### Примеры Django ORM Запросов

#### CREATE
```python
# создание карточки
card = Card.objects.create(
    question='Python or perl?',
    answer='Python',
)
card.save()

# проверка существования тега и создание нового тега если его не существует
tag, created = Tag.objects.get_or_create(name='IronPython')
# вернётся кортеж, в первом элементе которого будет объект тега, во втором - булевое значение создан ли тег

# создание новой категории
category = Category.objects.create(name='Random')

# добавление тега к карточке со связью многие ко многим
# ???????
```

#### READ
```python
# получение всех карточек
cards = Card.objects.all()

# получение карточки по идентификатору
card = Card.objects.get(id=337)
card = Card.objects.get(pk=337)

# получение всех тегов связанных с карточкой
tags = card.tags.all()

# получение карточек по тегу (два варианта)
cards = Card.objects.filter(tags__name='синтаксис')
cards = Tag.objects.get(name='синтаксис').cards.all()

# получение всех категорий
categories = Category.objects.all()
```

#### UPDATE
```python
# обновление карточки по id
card = Card.objects.get(pk=457)
card.question = 'Как выглядит "Hello, world!" на Python?'
card.save()

# изенение имени категории
category = Category.objects.get(name='JavaScript')
category.name = 'JS'
category.save()
```

#### DELETE
```python
# удаление карточки по id 457
card = Card.objects.get(pk=457)
card.delete()

# удаление категории по имени
category = Category.objects.get(name='JS')
category.delete()
```

#### Q объекты
```python
from django.db.models import Q

# получение карточек, которые содержат в вопросе слово "Java"
cards = Card.objects.filter(question__contains='Java')

# получение карточек, которые содержат слово "Java" в вопросе или ответе
cards = Card.objects.filter(Q(question__contains='Java') | Q(answer__contains='Java'))

# получение только тех карточек, которые содержат слова "Java" в вопросе и ответе
cards = Card.objects.filter(Q(question__contains='Java') & Q(answer__contains='Java'))
```

#### F объекты
```python
from django.db.models import F

# Увеличение количества просмотров на 1 для всех карточек
Card.objects.update(views=F("views") + 1)

# Установка количества добавлений в избранное равным количеству просмотров
Card.objects.update(adds=F("views"))

# Добавление 10 просмотров каждой карточке, ответ которой содержит слово SQL
Card.objects.filter(Q(answer__icontains="SQL")).update(views=F("views") + 10)
```

**commit: `lesson_52: посмотрели запросы Django ORM на CRUD`**


## Lesson 53

- добавили поля для отображения в админ. панели с помощью `list_display`
- пометили поля, которые будут ссылками с помощью `list_display_links`
- добавили поля по которым будет проводиться поиск с помощью `search_fields`
- добавили поля по которым будет проводиться фильтрация с помощью `list_filter`

**commit: `lesson_53: провели первоначальную настройку админ. панели`**


- добавили сортировку по категории по возрастанию  и по просмотрам по убыванию с помощью `ordering`
- изменили количество отображаемых карточек на странице админ. панели с помощью `list_per_page`
- задали поля, которые можно менять напрямую `list_editable`

**commit: `lesson_53: дополнительные настройки амдин. панели`**

- познакомились с методом `get_absolute_url`
В Django метод `get_absolute_url` используется в моделях для получения URL-адреса, который однозначно
идентифицирует объект модели.
Полезен для создания ссылок на конкретные модели, например в админ. панели Django или в шаблонах.

**commit: `lesson_53: get_absolute_url для создания URL-адреса`**

- поменяли надписи в шапке, заголовке и на экране приветствия админ. панели

**commit: `lesson_53: изменили заголовок, экран приветствия и шапку админ. панели`**

- поменяли заголовок, тайтл и приветствие в админ. панели в файле `anki\urls.py`
- перевели все поля в админ. панели на русский язык с помощью параметра `verbose_name` в каждом поле модели `Card`

**commit: `lesson_53: перевели все поля в админ. панели на русский язык`**

#### добавили поле `status` в модель `Card`
- тип `BooleanField` используется для хранения булевых значений (`True` или `False`).
- параметр `choices` используется для ограничения возможных значений поля и для удобного отображения этих значений в админке Django.
- В данном случае, `choices` задается с помощью `tuple(map(lambda x: (bool(x[0]), x[1]), Status.choices))`.

_нам нужно было ограничить значения поля `status` только двумя возможными состояниями: `True` (Проверено) и `False` (Не проверено).
Для этого используется `BooleanField`, который по своей сути ограничивает значения до двух возможных вариантов._

- `Status.choices` возвращает кортеж кортежей вида `((0, 'Не проверено'), (1, 'Проверено'))`.
- С помощью `map(lambda x: (bool(x[0]), x[1]), Status.choices)` эти значения преобразуются в булевы значения: `((False, 'Не проверено'), (True, 'Проверено'))`.
- Это позволяет использовать `BooleanField` с человеко-читаемыми именами для значений.

**commit: `lesson_53: добавили поле status`**

- добавили в админ. панель поле указывающее на наличие кода в ответе карточки
- добавили в админ. панель дополнительные действия: пометить карточки как проверенные и как не проверенные

**commit: `lesson_53: добавили в админ. панель поле наличие кода и дополнительные действия`**

##### Класс `CardCodeFilter`
Наследуется от `SimpleListFilter`, который предоставляет базовую функциональность для создания простых фильтров в админке Django.

##### Атрибут `title`
Задает название фильтра, которое будет отображаться в админке. В данном случае, это "Наличие кода".

##### Атрибут `parameter_name`
Задает имя параметра, которое будет использоваться в URL для фильтрации. В данном случае, это `has_code`.

##### Метод `lookups`
Возвращает кортеж кортежей, где каждый внутренний кортеж состоит из двух элементов: значения параметра и человеко-читаемого названия.
В данном случае, возвращаются два варианта: `('yes', 'Да')` и `('no', 'Нет')`.

##### Метод `queryset`
Принимает запрос `request` и исходный набор данных `queryset`.
В зависимости от значения параметра `has_code` (которое можно получить с помощью `self.value()`), фильтрует набор данных.
Если значение параметра `has_code` равно `yes`, фильтрует набор данных, чтобы включить только те карточки, в которых поле `answer` содержит строку с тремя тиками.
Если значение параметра `has_code` равно `no`, фильтрует набор данных, чтобы исключить карточки, в которых поле `answer` содержит строку с тремя тиками.

**commit: `lesson_53: добавили кастомный фильтр по наличию кода в ответе карточки`**

- установили `django-jazzmin` и настроили его
- `pip install django-jazzmin`
- Добавил `jazzmin` в `INSTALLED_APPS` в файле `settings.py`

**commit: `lesson_53: установил и настроил django-jazzmin`**


## Lesson 54

- Сделал копию служебного шаблона `change_form.html` и вклинились в `{% block after_field_sets %}`
- Добавил в админке карточек кнопку "Создать карточку с тегами" `{% block object-tools-items %}`

**commit: `lesson_54: кастомизация шаблона change_form.html`**

- добавили маршрут `preview_card_ajax/` для загрузки предпросмотра карточки
- добавили представление `preview_card_ajax` для загрузки предпросмотра карточки
- добавили JS-код в `change_form_custom.html` для загрузки предпросмотра карточки

**commit: `lesson_54: добавили обновление предпросмотра карточки в админке в реальном времени`**

- Удалить файл с БД `anki.db`
- Применить инициирующие миграции, которые создадут системные таблицы `python manage.py migrate`
- Создать админа `python manage.py createsuperuser`
- Создать миграции по структурам прописанным в БД `python manage.py makemigrations`
- Применить миграцию, созданную в предыдущем шаге `python manage.py migrate`
- Залить данные из `dump.json` в новую БД `python manage.py loaddata dump.json`

**commit: `lesson_54: загрузили содержимое БД из дампа`**

### Формы в Django
- Создали форму не связанную с моделью. Форма для добавления карточек
- Создали представление, обрабатывающее метод POST и возвращающее форму
- Создали шаблон для формы
- Протестировали работу формы
- Проверили валидацию формы

**commit: `lesson_54: базовая форма для добавления карточек`**

- Дополнили шаблон с построчным рендером полей ввода
- Добавили категорию как выпадающий список `form.ChoiceField`

**commit: `lesson_54: дополнил шаблон с построчным рендером полей ввода`**


## Lesson 55

- повторили разницу между ЛЕНИВОЙ и ЖАДНОЙ загрузкой
- `select_related` используется для оптимизации запросов, когда необходимо получить связанные объекты через "один ко многим" или "один к одному" отношения. Это уменьшает количество запросов к базе данных, выполняя более сложный запрос с JOIN'ами, но возвращая все необходимые данные за один запрос.
- `prefetch_related` применяется в случаях, когда связи "многие ко многим" или обратные связи "один ко многим" присутствуют. В отличие от `select_related`, `prefetch_related` выполняет отдельный запрос для каждой связи, но затем объединяет результаты в Python, что может существенно сократить время выполнения запроса при работе с большими объемами данных.

**commit: `lesson_55: вернули жадную загрузку всего каталога карточек`**

- Передали классы и атрибуты в форму через класс формы
- Поправили шаблон и перешли на `BS-5` с адаптивной вёрсткой
- Добавили обработку формы и сохранение данных в представлении

**commit: `lesson_55: BS5 и сохранение данных из формы`**

- Описали собственный класс валидатор `CodeBlockValidator`
- Подключили его в форме

**commit: `lesson_55: собственный валидатор CodeBlockValidator`**

- Написали форму связанную с моделью
- Обновили представление, чтобы оно работало с формой связанной с моделью
- Код получился вдвое короче
- Добавили валидатор для поля `tags` в форме (отсутствие пробелов)
- Добавили метод очистки тегов в форме
- Проверили работу формы
- !!! рассказать подробнее про `super().save(commit=False)`

**commit: `lesson_55: форма добавления карточек связанная с моделью`**

- Базовая форма добавления файла
- Минимальный комплект: класс формы, представление, шаблон
- Получения файла через `chunks()` и сохранение его в файловую систему

**commit: `lesson_55: базовая форма добавления файла`**


## Lesson 56

- Модифицировали функцию-представление `catalog` в файле `views.py` так, чтобы она принимала GET-параметр `search_query`
- Добавили в шаблон `catalog.html` форму для поиска карточек с GET-параметром `search_query` и радио-кнопками для выбора поля поиска
- Протестировали работу поиска
- Добавили отключение кеширования браузера для страницы каталога, чтобы видеть увеличение просмотров в каталоге

**commit: `lesson_56: добавили поиск по карточкам`**

- Добавили экземпляр пагинатора в представление `catalog` в файле `views.py`
- Добавили работу с пагинатором в шаблоне `catalog.html`

**commit: `lesson_56: добавил пагинацию в каталог карточек`**

### Классовые представления

- Переписали функцию представления add_card на классовое представление с наследованием от `View`

**commit: `lesson_56: переписали функцию представления add_card на классовое представление`**

- Переписали `about` и главную страницу на классовые представления (наследование от `TemplateView`)
- Создали миксин, который добавляет к контексту меню, подмешали его в один класс

**commit: `lesson_56: переписали about и главную страницу на TemplateView`**

- Добавили в `AboutView` и `IndexView` атрибут `extra_context` и добавили в него подсчет
реального количества карточек и пользователей

**commit: `lesson_56: добавили в AboutView и IndexView подсчет реального количества карточек и пользователей`**


## Lesson 57

### ListView
- Переписали представление `catalog` на классовое представление `ListView`
- Добавили жадную загрузку связанных объектов
- Добавили подсчёт карточек и пользователей в `MenuMixin` для использования в `AboutView` и `IndexView`

**commit: `lesson_57: Переписали представление catalog на классовое представление ListView`**

- Использовали `__iregex` для РАБОЧЕГО регистронезависимого поиска вместо `__icontains` (актуально для SQLite)
- Кешировали каталог силами шаблонизатора
- Использовали `page_obj.paginator.count` для подсчета количества карточек (не иницирует новых запросов к БД)
- Использовали переменные для кеша, которые позволяют кешировать разные варианты страницы (по запросам и сортировкам)`{% cache 90 catalog_content page_obj.number sort order search_query %}`

**commit: `lesson_57: доработка каталога и кеширование`**

### DetailView
- Переписали представление `get_detail_card_by_id` на классовое представление `DetailView`
- Обновили шаблон `card_detail.html` для работы с классовым представлением
- Переписали маршрут для детального отображения карточки
- Добавили немного адаптивности в шаблоны `card_detail.html` и `card_preview.html`

**commit: `lesson_57: get_detail_card_by_id на классовое представление DetailView`**

### Кеширование MenuMixin
- Использовали `from django.core.cache import cache` для кеширования меню, так как оно делало с каждой страницы по 2 запроса в БД

**commit: `lesson_57: кеширование меню с помощью cache`**

### CreateView
- Переписали представление добавления карточки на классовое представление `CreateView` - `AddCardCreateView(MenuMixin, CreateView)`

**commit: `lesson_57: добавление карточки на классовое представление CreateView`**


## Lesson 58

Параметр `ALLOWED_HOSTS` в настройках Django (`settings.py`) используется для указания списка доменов и поддоменов, которые могут обслуживать ваше приложение. Этот параметр является важным с точки зрения безопасности и функциональности.

Вот несколько ключевых причин, почему `ALLOWED_HOSTS` важен:

1. **Безопасность**:
   - `ALLOWED_HOSTS` помогает предотвратить атаки, такие как HTTP Host Header attacks. Злоумышленники могут попытаться обмануть ваше приложение, отправив запросы с поддельными заголовками `Host`. Указание разрешенных доменов помогает защитить ваше приложение от таких атак.

2. **Функциональность**:
   - Django использует значение заголовка `Host` для генерации URL-адресов, которые могут быть использованы в различных частях приложения, таких как ссылки в шаблонах, редиректы и т.д. Если заголовок `Host` не соответствует одному из разрешенных доменов, Django выдаст ошибку `SuspiciousOperation`.

3. **Разработка и тестирование**:
   - Во время разработки и тестирования вы можете использовать различные домены (например, `localhost`, `127.0.0.1`, `yourdomain.com`). Указание этих доменов в `ALLOWED_HOSTS` позволяет вам легко переключаться между различными средами без необходимости изменять код.

Пример использования `ALLOWED_HOSTS` в `settings.py`:

```python
ALLOWED_HOSTS = [
    'localhost',
    '127.0.0.1',
    'yourdomain.com',
    'www.yourdomain.com',
]
```

Если вы не уверены, какие домены будут использоваться, вы можете временно установить `ALLOWED_HOSTS` в `['*']`, что разрешит все домены. Однако это не рекомендуется для продакшн-среды из соображений безопасности.

```python
ALLOWED_HOSTS = ['*']
```

В продакшн-среде всегда указывайте конкретные домены, которые будут использоваться вашим приложением.

### UpdateView и DeleteView
- Добавили представления `UpdateView` и `DeleteView` для редактирования и удаления карточек
- А так же удачную правку для тегов, чтобы они на самом деле обновлялись (а не только добавлялись)
- Шаблон для `404` ошибки (работает только в боевом режиме `DEBUG=False`, не забыть прописать `ALLOWED_HOSTS=['*']` в `settings.py`)

**commit: `lesson_58: UpdateView и DeleteView и 404`**

### Users app
- Создали приложение `users` с помощью команды `python manage.py startapp users`
- Подключили приложение `users` в `INSTALLED_APPS`
- Подготовили маршруты (`users/urls.py`) и представления(`users/views.py`) для приложения `users`

**commit: `lesson_58: users app и подготовка маршрутов`**

- прописали функции-представления для аутентификации и выхода из системы
- создали шаблон для входа в систему
- `LoginUserForm` — форма для входа в систему
- протестировали вход и выход из системы
- нашли в браузере куки и сессии

**commit: `lesson_58: функции-представления для аутентификации и выхода из системы`**

- `redirect_field_name` = 'next' во вьюшке добавления карточек
- так же, добавили миксин `LoginRequiredMixin` для защиты представлений от неавторизованных пользователей
- в шаблон `login.html` добавили `next` для перехода на страницу, с которой пришел пользователь
`<input type="hidden" name="next" value="{{ request.GET.next }}">`
- пофиксили редирект при успешной авторизации `return redirect(request.POST.get('next', 'catalog'))` — это позволяет переходить на страницу, с которой пришел пользователь после авторизации

**commit: `lesson_58: защита представлений от неавторизованных пользователей и перенаправление`**

- добавили в навигационное меню кнопки Вход и Регистрация

**commit: `lesson_58: добавили в навигационное меню кнопки Вход и Регистрация`**

HTTP (HyperText Transfer Protocol) — это протокол прикладного уровня, используемый для передачи данных в сети, обычно в интернете. Он является основой для обмена данными в веб-браузерах и веб-серверах. HTTP работает по модели "запрос-ответ": клиент (например, веб-браузер) отправляет запрос на сервер, а сервер отвечает на этот запрос.

### Основные методы HTTP

1. GET:
   - Используется для запроса данных с сервера.
   - Параметры запроса передаются в URL.
   - Пример: GET /index.html HTTP/1.1

2. POST:
   - Используется для отправки данных на сервер, например, при отправке формы.
   - Данные передаются в теле запроса.
   - Пример: POST /submit-form HTTP/1.1

3. PUT:
   - Используется для обновления ресурса на сервере.
   - Данные передаются в теле запроса.
   - Пример: PUT /update-resource HTTP/1.1

4. DELETE:
   - Используется для удаления ресурса на сервере.
   - Пример: DELETE /delete-resource HTTP/1.1

5. HEAD:
   - Аналогичен GET, но сервер возвращает только заголовки ответа без тела.
   - Пример: HEAD /index.html HTTP/1.1

6. OPTIONS:
   - Используется для запроса информации о доступных методах и других опциях для указанного ресурса.
   - Пример: OPTIONS /resource HTTP/1.1

7. PATCH:
   - Используется для частичного обновления ресурса на сервере.
   - Данные передаются в теле запроса.
   - Пример: PATCH /update-resource HTTP/1.1

8. TRACE:
   - Используется для диагностики, возвращает запрос, полученный сервером.
   - Пример: TRACE /resource HTTP/1.1

9. CONNECT:
   - Используется для установления туннеля к серверу, обычно для SSL через прокси.
   - Пример: CONNECT www.example.com:443 HTTP/1.1

### Структура HTTP-запроса

HTTP-запрос состоит из нескольких частей:

1. Стартовая строка:
   - Содержит метод, URI (Uniform Resource Identifier) и версию протокола.
   - Пример: GET /index.html HTTP/1.1

2. Заголовки:
   - Содержат метаинформацию о запросе.
   - Пример: Host: www.example.com

3. Тело запроса (если есть):
   - Содержит данные, отправляемые на сервер (например, в POST-запросе).

### Структура HTTP-ответа

HTTP-ответ также состоит из нескольких частей:

1. Стартовая строка:
   - Содержит версию протокола, код состояния и текстовое описание состояния.
   - Пример: HTTP/1.1 200 OK

2. Заголовки:
   - Содержат метаинформацию об ответе.
   - Пример: Content-Type: text/html

3. Тело ответа (если есть):
   - Содержит данные, возвращаемые сервером (например, HTML-страницу).

### Коды состояния HTTP

Коды состояния HTTP делятся на несколько категорий:

- 1xx (Информационные): Запрос получен, продолжается обработка.
- 2xx (Успешные): Запрос успешно обработан.
- 3xx (Перенаправления): Для завершения запроса требуется дополнительное действие.
- 4xx (Ошибки клиента): Запрос содержит ошибку.
- 5xx (Ошибки сервера): Сервер не смог обработать запрос.

Примеры кодов состояния:
- 200 OK: Запрос успешно обработан.
- 404 Not Found: Ресурс не найден.
- 500 Internal Server Error: Внутренняя ошибка сервера.

HTTP является основой для работы веб-приложений и веб-сервисов, обеспечивая стандартизированный способ взаимодействия между клиентами и серверами.

**commit: `lesson_58: дополнительная информация по HTTP-протоколу`**


## Lesson 59

### Переписали функцию логина на LoginUser(LoginView)
- Использовали `LoginView` вместо функции `login_user` - это классовое представление для входа в систему
- В нем использовали служебную (встроенную) форму `AuthenticationForm` для входа в систему
- А так же прописали `success_url` для перехода после успешного входа с проверкой на `next`
- 
**commit: `lesson_59: переписали функцию логина на LoginUser(LoginView)`**

- Написали свою форму с наследованием от `AuthenticationForm` и добавили в нее BS5 стили
- Переписали представление выхода из системы на `LogoutUser(LogoutView)`
- Добавили оформления в шаблон `login.html`
- 
**commit: `lesson_59: своя форма входа и выхода из системы`**

- Прописал в настройках `LOGIN_URL` для того, чтобы не делать это в каждом защищенном представлении
- Убрал `login_url` из защищенного представления и проверил работу
- `LoginRequiredMixin` работает в связке с полем |`login_url` из защищённого представления или с параметром `LOGIN_URL` из настроек
- 
**commit: `lesson_59: LoginRequiredMixin и LOGIN_URL`**

### Добавление пользователя в описание карточки
- добавили автора в модель данных `Card` `author = models.ForeignKey(get_user_model(), on_delete=models.SET_NULL, related_name='cards', null=True, default=None, verbose_name=_('Автор'))`
- Добавили пользователя в шаблоны отображения карточек
- Модифицировали `AddCardCreateView` для добавления карточки, чтобы автором был текущий пользователь

**commit: `lesson_59: добавил пользователя в описание карточки`**

- `class LogoutUser(LogoutView): next_page = reverse_lazy('users:login')`
- Поправили `urls.py` для приложения `users` c использованием класса `LogoutUser`

**commit: `lesson_59: LogoutUser(LogoutView)`**

- Регистрация пользователя через простую форму связанную с моделью `RegisterUserForm(forms.ModelForm):`
- Функция представления `register_user` для регистрации пользователя
- Шаблон `register.html` для регистрации пользователя
- Сообщение спасибо за регистрацию `register_done.html`
  
**commit: `lesson_59: регистрация пользователя`**

DNS (Domain Name System) — это фундаментальная технология, которая делает Интернет доступным и удобным для пользователей. Представьте себе, что DNS — это своего рода телефонная книга Интернета, которая позволяет вам находить веб-сайты и другие ресурсы по удобным для запоминания именам, а не по сложным числовым адресам. Давайте рассмотрим, почему DNS так важен и как он работает, с помощью интересных аналогий и примеров.

### Почему DNS так важен?

1. Удобство для пользователей:
   - Представьте, что вместо ввода www.example.com вам нужно запомнить и вводить что-то вроде 93.184.216.34. Это было бы очень неудобно и затруднительно. DNS позволяет использовать легко запоминающиеся доменные имена, что делает навигацию по Интернету гораздо проще.

2. Гибкость и управление:
   - DNS позволяет владельцам веб-сайтов и других онлайн-ресурсов легко управлять своими доменными именами и IP-адресами. Например, если ваш веб-сайт переезжает на новый сервер с другим IP-адресом, вам нужно просто обновить записи DNS, и пользователи будут автоматически перенаправлены на новый сервер.

3. Распределение нагрузки и отказоустойчивость:
   - DNS может направлять трафик на разные серверы в зависимости от географического положения пользователя или текущей нагрузки на серверы. Это помогает распределить нагрузку и обеспечить высокую доступность веб-сайтов и других онлайн-сервисов.

4. Безопасность:
   - DNSSEC (DNS Security Extensions) добавляет уровень безопасности, защищая DNS-запросы от подделки и других атак. Это помогает предотвратить перенаправление пользователей на поддельные веб-сайты.

### Как работает DNS?

Представьте, что вы хотите посетить веб-сайт www.example.com. Вот что происходит за кулисами:

1. Запрос к рекурсивному DNS-серверу:
   - Ваш браузер отправляет запрос к рекурсивному DNS-серверу, который обычно предоставляется вашим интернет-провайдером или настроен в вашей операционной системе.

2. Запрос к корневому DNS-серверу:
   - Если рекурсивный DNS-сервер не знает IP-адреса для www.example.com, он отправляет запрос к корневому DNS-серверу. Корневой сервер отвечает, что за доменом .com отвечает TLD-сервер.

3. Запрос к TLD-серверу:
   - Рекурсивный DNS-сервер отправляет запрос к TLD-серверу для домена .com. TLD-сервер отвечает, что за доменом example.com отвечает авторитетный DNS-сервер.

4. Запрос к авторитетному DNS-серверу:
   - Рекурсивный DNS-сервер отправляет запрос к авторитетному DNS-серверу для домена example.com. Авторитетный сервер отвечает IP-адресом для www.example.com.

5. Ответ пользователю:
   - Рекурсивный DNS-сервер возвращает IP-адрес вашему браузеру, и браузер устанавливает соединение с веб-сервером по этому IP-адресу.

### Интересные факты о DNS

- История DNS:
  - DNS был разработан в 1980-х годах, когда Интернет только начинал развиваться. До этого использовался файл hosts, который содержал список всех доменных имен и соответствующих им IP-адресов. По мере роста Интернета этот подход стал неэффективным, и была разработана распределенная система DNS.

- Корневые DNS-серверы:
  - В мире существует всего 13 корневых DNS-серверов, которые управляют корневой зоной DNS. Эти серверы распределены по всему миру и обеспечивают высокую доступность и отказоустойчивость.

- DNS-кэширование:
  - Рекурсивные DNS-серверы кэшируют ответы на запросы, чтобы ускорить последующие запросы. Это снижает нагрузку на авторитетные серверы и улучшает производительность.

- DNS-атаки:
  - DNS может быть уязвим для различных атак, таких как DNS-спуфинг (подделка DNS-ответов) и DDoS-атаки (распределенные атаки типа "отказ в обслуживании"). Для защиты от таких атак используются технологии, такие как DNSSEC и Anycast.

DNS — это невидимый герой Интернета, который работает в фоновом режиме, обеспечивая надежное и удобное преобразование доменных имен в IP-адреса. Без DNS Интернет был бы гораздо менее удобным и доступным для пользователей.

**commit: `lesson_59: информация о DNS`**


## Lesson 60

### Класс регистрации пользователя RegisterUser
- Переписали функцию регистрации на класс `RegisterUser(CreateView)` — специализированного родителя нет, поэтому используем `CreateView`
- Поправили `urls.py` для приложения `users` c использованием класса `RegisterUser`
- Переписали старую форму на класс `RegisterUserForm(UserCreationForm)` — специлизированный родитель для регистрации пользователя
- Протестировали хеширование пароля (Есть!)

**commit: `lesson_60: класс регистрации пользователя RegisterUser`**

### Авторизация опционально через email или username

- Создаем файл бэкенда аутентификации `users/authentication.py`
- Определяем в нем собственный бэкенд
- Подключаем его в настройках `AUTHENTICATION_BACKENDS`
- Указываем там стандартный бэкенд `django.contrib.auth.backends.ModelBackend` и наш собственный `users.authentication.EmailAuthBackend`
- Поправили форму входа `LoginUserForm` (подпись что вы можете войти по `email` или `username`)

В файле `settings.py` Django содержится множество констант, которые настраивают различные аспекты вашего приложения. Вот некоторые из основных констант и их назначение:

1. **BASE_DIR**:
   - **Описание**: Путь к корневой директории проекта.
   - **Пример**: `BASE_DIR = Path(__file__).resolve().parent.parent`

2. **SECRET_KEY**:
   - **Описание**: Секретный ключ, используемый для криптографических операций.
   - **Пример**: `SECRET_KEY = 'your-secret-key'`

3. **DEBUG**:
   - **Описание**: Флаг, указывающий, включен ли режим отладки.
   - **Пример**: `DEBUG = True`

4. **ALLOWED_HOSTS**:
   - **Описание**: Список доменных имен, которые могут обслуживать этот Django-сайт.
   - **Пример**: `ALLOWED_HOSTS = ['localhost', '127.0.0.1']`

5. **INSTALLED_APPS**:
   - **Описание**: Список приложений, которые должны быть включены в проект.
   - **Пример**:
     ```python
     INSTALLED_APPS = [
         'django.contrib.admin',
         'django.contrib.auth',
         'django.contrib.contenttypes',
         'django.contrib.sessions',
         'django.contrib.messages',
         'django.contrib.staticfiles',
         'your_app_name',
     ]
     ```

6. **MIDDLEWARE**:
   - **Описание**: Список middleware-классов, которые будут использоваться для обработки запросов и ответов.
   - **Пример**:
     ```python
     MIDDLEWARE = [
         'django.middleware.security.SecurityMiddleware',
         'django.contrib.sessions.middleware.SessionMiddleware',
         'django.middleware.common.CommonMiddleware',
         'django.middleware.csrf.CsrfViewMiddleware',
         'django.contrib.auth.middleware.AuthenticationMiddleware',
         'django.contrib.messages.middleware.MessageMiddleware',
         'django.middleware.clickjacking.XFrameOptionsMiddleware',
     ]
     ```

7. **ROOT_URLCONF**:
   - **Описание**: Путь к модулю, содержащему корневой URLconf.
   - **Пример**: `ROOT_URLCONF = 'your_project_name.urls'`

8. **TEMPLATES**:
   - **Описание**: Настройки для шаблонизаторов.
   - **Пример**:
     ```python
     TEMPLATES = [
         {
             'BACKEND': 'django.template.backends.django.DjangoTemplates',
             'DIRS': [BASE_DIR / 'templates'],
             'APP_DIRS': True,
             'OPTIONS': {
                 'context_processors': [
                     'django.template.context_processors.debug',
                     'django.template.context_processors.request',
                     'django.contrib.auth.context_processors.auth',
                     'django.contrib.messages.context_processors.messages',
                 ],
             },
         },
     ]
     ```

9. **WSGI_APPLICATION**:
   - **Описание**: Путь к WSGI-приложению.
   - **Пример**: `WSGI_APPLICATION = 'your_project_name.wsgi.application'`

10. **DATABASES**:
    - **Описание**: Настройки для баз данных.
    - **Пример**:
      ```python
      DATABASES = {
          'default': {
              'ENGINE': 'django.db.backends.sqlite3',
              'NAME': BASE_DIR / 'db.sqlite3',
          }
      }
      ```

11. **AUTH_PASSWORD_VALIDATORS**:
    - **Описание**: Список валидаторов паролей.
    - **Пример**:
      ```python
      AUTH_PASSWORD_VALIDATORS = [
          {
              'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
          },
          {
              'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
          },
          {
              'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
          },
          {
              'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
          },
      ]
      ```

12. **LANGUAGE_CODE**:
    - **Описание**: Код языка по умолчанию.
    - **Пример**: `LANGUAGE_CODE = 'en-us'`

13. **TIME_ZONE**:
    - **Описание**: Часовой пояс по умолчанию.
    - **Пример**: `TIME_ZONE = 'UTC'`

14. **USE_I18N**:
    - **Описание**: Флаг, указывающий, включена ли интернационализация.
    - **Пример**: `USE_I18N = True`

15. **USE_L10N**:
    - **Описание**: Флаг, указывающий, включена ли локализация.
    - **Пример**: `USE_L10N = True`

16. **USE_TZ**:
    - **Описание**: Флаг, указывающий, включена ли поддержка временных зон.
    - **Пример**: `USE_TZ = True`

17. **STATIC_URL**:
    - **Описание**: URL-префикс для статических файлов.
    - **Пример**: `STATIC_URL = '/static/'`

18. **DEFAULT_AUTO_FIELD**:
    - **Описание**: Поле по умолчанию для автоматически создаваемых первичных ключей.
    - **Пример**: `DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'`

Эти константы являются лишь частью всех возможных настроек, которые можно использовать в `settings.py`. В зависимости от ваших потребностей, вы можете добавлять и изменять другие настройки, такие как настройки для кэширования, аутентификации, электронной почты и т.д.

**commit: `lesson_60: авторизация опционально через email или username`**

### Начали работу над личным кабинетом

#### Шаблоны
- Создали шаблон `base_profile.html` который расширяет `base.html` и служит основой для личного кабинета
- Создали шаблон `profile.html` который расширяет `base_profile.html` и содержит информацию о пользователе а так же возможность внести изменения в профиль
- Создали include `profile_nav.html` для навигации по личному кабинету
- Создали шаблон `password_change_form.html` для изменения пароля
- Создали шаблон `password_change_done.html` для успешного изменения пароля
- Создали шаблон `profile_cards.html` для отображения карточек пользователя
#### Маршруты
- `users/profile/` - `ProfileUser` - личный кабинет пользователя
- `users/password_change/` - `UserPasswordChange` - изменение пароля пользователя
- `users/profile_cards/` - `UserCardsView` - карточки пользователя
#### Представления
- `UserPasswordChange` - изменение пароля пользователя. Наследуется от `PasswordChangeView` - стандартного класса для изменения пароля. Использует пользовательскую форму `UserPasswordChangeForm`, которая наследуется от `PasswordChangeForm`
- `UserPasswordChangeDone` - успешное изменение пароля пользователя. Наследуется от `TemplateView`
- `UserCardsView` - карточки пользователя. Наследуется от `ListView`. Переопределяет метод `get_queryset` для получения карточек пользователя
- 
**commit: `lesson_60: начал работу над личным кабинетом`**


## Lesson 61

### Восстановление пароля через email
Для этого нам необходимо подготовить целый ряд представлений и шаблонов:

Итого для работы с паролями:
### Классы и их функциональность

1. **PasswordChange**
   - Родитель: `PasswordChangeView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону формы смены пароля.
     - `form_class`: Указать класс формы для смены пароля.
     - `success_url`: Использовать `reverse_lazy` для указания URL-адреса перенаправления после успешной смены пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Смена пароля'}`.
   - Методы:
     - `form_valid`: Метод, вызываемый при успешной валидации формы. Может быть переопределен для добавления дополнительной логики.
2. **PasswordChangeDone**
   - Родитель: `TemplateView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону страницы, подтверждающей успешное изменение пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Пароль успешно изменен'}`.
3. **PasswordReset**
   - Родитель: `PasswordResetView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону формы запроса на сброс пароля.
     - `form_class`: Указать класс формы для запроса сброса пароля.
     - `email_template_name`: Путь к шаблону email, который будет отправлен для сброса пароля.
     - `success_url`: Использовать `reverse_lazy` для указания URL-адреса перенаправления после запроса на сброс.
     - `subject_template_name`: Путь к шаблону темы email.
   - Методы:
     - `form_valid`: Метод для дополнительной обработки после отправки формы.
4. **PasswordResetDone**
   - Родитель: `TemplateView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону страницы, подтверждающей отправку инструкций по сбросу пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Инструкции отправлены'}`.
5. **PasswordResetConfirm**
   - Родитель: `PasswordResetConfirmView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону формы для ввода нового пароля.
     - `form_class`: Указать класс формы для ввода нового пароля.
     - `success_url`: Использовать `reverse_lazy` для указания URL-адреса перенаправления после успешного сброса пароля.
   - Методы:
     - `form_valid`: Метод для дополнительной обработки после успешной смены пароля.
6. **PasswordResetComplete**
   - Родитель: `TemplateView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону страницы, подтверждающей успешное обновление пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Пароль успешно обновлен'}`.

#### Служебный синтаксис в методах
- `reverse_lazy('name_of_route')`: Используется для отложенного получения URL по имени маршрута.
- `form_valid(form)`: Вызывается, когда форма проходит валидацию. Обычно используется для переопределения стандартной логики, например, для выполнения дополнительных действий с объектом перед его сохранением.
Эти элементы должны быть включены в классы и методы для обеспечения функциональности смены и восстановления пароля, а также управления потоком пользователя в приложении Django.
#### Таблица классов и представлений:
| Класс                     | Файл                | Родитель                       | Описание                                                    | Использование                  |
| ------------------------- | ------------------- | ------------------------------ | ----------------------------------------------------------- | ------------------------------ |
| `PasswordChange`          | `views.py`          | `PasswordChangeView`           | Класс для смены пароля аутентифицированного пользователя.    | Смена пароля                   |
| `PasswordChangeDone`      | `views.py`          | `TemplateView`                 | Отображает страницу об успешном изменении пароля.            | Подтверждение смены пароля     |
| `PasswordReset`           | `views.py`          | `PasswordResetView`            | Обработчик для инициирования процесса сброса пароля.         | Восстановление пароля          |
| `PasswordResetDone`       | `views.py`          | `TemplateView`                 | Отображает страницу, подтверждающую отправку инструкций.     | Подтверждение отправки письма  |
| `PasswordResetConfirm`    | `views.py`          | `PasswordResetConfirmView`     | Позволяет пользователю ввести новый пароль после сброса.     | Ввод нового пароля             |
| `PasswordResetComplete`   | `views.py`          | `TemplateView`                 | Отображает страницу об успешном обновлении пароля.           | Успешное обновление пароля     |

#### Шаблоны

**Шаблоны сброса пароля Django:**
* `password_reset_email.html`: используется для отправки электронного письма с ссылкой для сброса пароля.
* `password_reset_form.html`: используется для отображения формы сброса пароля.
* `password_reset_confirm.html`: используется для отображения страницы подтверждения сброса пароля.
* `password_reset_done.html`: используется для отображения страницы с сообщением о том, что пароль был успешно сброшен.
* `password_change_email.html`: используется для отправки электронного письма с уведомлением о смене пароля.
* `password_change_form.html`: используется для отображения формы изменения пароля.
* `password_change_done.html`: используется для отображения страницы с сообщением о том, что пароль был успешно изменен.
**Описание каждого шаблона:**
* **password_reset_email.html:** 
   * Этот шаблон используется для отправки электронного письма с ссылкой для сброса пароля. 
   * Шаблон должен содержать ссылку, которая направляет пользователя на страницу сброса пароля. 
   * Ссылка должна содержать уникальный идентификатор пользователя и токен сброса пароля.
   * Шаблон также может содержать сообщение с инструкциями о том, как сбросить пароль.
* **password_reset_form.html:**
   * Этот шаблон используется для отображения формы сброса пароля. 
   * Форма должна содержать поля для ввода нового пароля и подтверждения нового пароля.
   * Форма должна также содержать скрытое поле с токеном сброса пароля.
   * Когда пользователь отправляет форму, Django проверит токен сброса пароля и, если он действителен, сбросит пароль пользователя.
* **password_reset_confirm.html:**
   * Этот шаблон используется для отображения страницы подтверждения сброса пароля. 
   * Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно сброшен.
   * Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.
* **password_reset_done.html:**
   * Этот шаблон используется для отображения страницы с сообщением о том, что пароль был успешно сброшен. 
   * Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно сброшен.
   * Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.
* **password_change_email.html:**
   * Этот шаблон используется для отправки электронного письма с уведомлением о смене пароля. 
   * Шаблон должен содержать сообщение с информацией о том, что пароль пользователя был изменен.
   * Шаблон также может содержать ссылку, которая направляет пользователя на страницу изменения пароля.
* **password_change_form.html:**
   * Этот шаблон используется для отображения формы изменения пароля. 
   * Форма должна содержать поля для ввода текущего пароля, нового пароля и подтверждения нового пароля.
   * Когда пользователь отправляет форму, Django проверит текущий пароль пользователя и, если он верен, изменит пароль пользователя.
* **password_change_done.html:**
   * Этот шаблон используется для отображения страницы с сообщением о том, что пароль был успешно изменен. 
   * Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно изменен.
   * Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.

**commit: `lesson_61: промежуточный коммит восстановление пароля через email`**

### Расширили модель пользователя
```python
from django.contrib.auth.models import AbstractUser
from django.db import models
class User(AbstractUser):
    photo = models.ImageField(
        upload_to='users/images/%Y/%m/%d',
        null=True,
        blank=True,
        verbose_name='Аватар'
    )
    date_birth = models.DateField(
        null=True,
        blank=True,
        verbose_name='Дата рождения'
    )
    groups = models.ManyToManyField(
        'auth.Group',
        related_name='custom_user_set',
        blank=True,
        verbose_name='groups',
    )
    user_permissions = models.ManyToManyField(
        'auth.Permission',
        related_name='custom_user_set',
        blank=True,
        verbose_name='user permissions',
    )
    def __str__(self):
        return self.username
```
В Django, `AbstractUser` - это базовый класс для модели пользователя, который включает в себя большинство полей и методов, необходимых для аутентификации и авторизации пользователей. Он включает такие поля, как `username`, `password`, `email`, `first_name`, `last_name`, `is_staff`, `is_active`, `date_joined` и другие.
Когда вы создаете свой собственный класс `User`, наследуясь от `AbstractUser`, вы переопределяете стандартную модель пользователя Django. Это позволяет вам добавить дополнительные поля, такие как `photo` и `date_birth`, которые не включены в стандартную модель пользователя.
Ваш класс `User` включает следующие поля:
- `photo`: Это поле `ImageField`, которое позволяет пользователям загружать фотографии. Параметр `upload_to` указывает, где эти фотографии должны быть сохранены. В данном случае, они сохраняются в подкаталоге `users/images/%Y/%m/%d/` каталога `MEDIA_ROOT`. Параметры `blank=True, null=True` указывают, что это поле не является обязательным.
- `date_birth`: Это поле `DateTimeField`, которое позволяет пользователям указывать свою дату рождения. Оно также не является обязательным.
Причина, по которой вы используете наследование от `AbstractUser`, а не связь "один к одному" с другой моделью для хранения дополнительной информации о пользователе, заключается в том, что это делает вашу модель пользователя более гибкой и удобной в использовании. Вместо того чтобы каждый раз, когда вам нужна дополнительная информация о пользователе, получать ее из связанной модели, вы можете просто обратиться к полям `photo` и `date_birth` напрямую, как если бы они были частью стандартной модели пользователя.
---
В Django, параметр `upload_to` в поле `ImageField` или `FileField` используется для указания подкаталога внутри `MEDIA_ROOT`, где будут сохраняться загруженные файлы.
Строка `'users/images/%Y/%m/%d/'` в `upload_to` определяет путь к подкаталогу, где будут сохраняться файлы. В этом пути используются специальные символы `%Y`, `%m` и `%d`, которые заменяются на текущий год, месяц и день соответственно. Это позволяет автоматически организовать загруженные файлы по датам, что может быть полезно, если вы ожидаете большое количество загружаемых файлов.
Таким образом, если пользователь загрузит файл 5 июля 2022 года, файл будет сохранен в подкаталоге `users/images/2022/07/05/` каталога `MEDIA_ROOT`.
Пожалуйста, учтите, что `MEDIA_ROOT` должен быть предварительно определен в настройках вашего Django проекта. Это корневой каталог, где Django будет сохранять все загруженные файлы.
---
- Установим pillow для работы с изображениями `pip install pillow`
- Обновим requirements.txt `pip freeze > requirements.txt`
- Создал новые миграции.
- Применил миграции.
- Подключим новую модель пользователя в настройках `AUTH_USER_MODEL = 'users.User'`
ВАЖНО:
Сначала создаём миграции, применяем их, и только потом подключаем новую модель пользователя в `settings.py` — `AUTH_USER_MODEL = 'users.User'` 

**commit: `lesson_61: расширил модель пользователя`**

- Правки в главный `urls.py` для отображения медиафайлов
```python
from django.conf.urls.static import static
from django.conf import settings

if settings.DEBUG:
    import debug_toolbar
    urlpatterns = [
                      path('__debug__/', include(debug_toolbar.urls)),
                      # другие URL-паттерны
                  ] + urlpatterns

# Добавляем обработку медиафайлов
urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```
- Правки в `nav_menu.html` для кликабельности username
```html
 <a class="nav-link" href="{% url 'users:profile' %}">{{ user.username }}</a>
```
А так же мелкие правки в стили для отображения фотографии пользователя

**commit: `lesson_61: добавили аватар в профиле`**

- Отсутствовал маршрут в `urls.py` для `UserPasswordChangeDone`
- Добавили его и протестировали работу смены пароля
- Отсутствовал параметр `context_object_name` в `UserCardsView`, из-за чего не грузились карточки пользователя

**commit: `lesson_61: доделал смену пароля в ЛК`**

#### Маршруты
- Маршрут для сброса пароля
- Маршрут для подтверждения сброса пароля
- Маршрут для ввода нового пароля
- Маршрут для завершения сброса пароля
- 
#### Settings 

Настраиваем `EMAIL_BACKEND` для вывода в консоль
```python
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
```

Сделали восстановление пароля через email

**commit: `lesson_61: восстановление пароля через email`**


## Lesson 62

### Подготовка к деплою
1. Регистрация на TimeWeb. https://timeweb.cloud/r/pj17346
2. Выбор тарифа и создание виртуального сервера.
3. Покупка домена и настройка его на TimeWeb. 
4. Подгтовка проекта к деплою
   1. Убедитесь что в проекте нет лишних файлов и папок.
   2. Создайте файл `requirements.txt` с зависимостями проекта.
   3. Если вы создавали `.env` файл, добавьте его в `.gitignore`.
   4. Убедитесь что `.env.example` содержит все необходимые переменные.
   5. Если в вашей БД есть контент, создайте дамп БД
   6. Можете прогнать тест. Просто склонируйте проект в соседнюю папку и попробуйте запустить.
5. Команды для подготовки приложения к запуску на сервере
6. Деплой

**commit: `lesson_62: подготовка к деплою`**

DNS (Domain Name System) — это фундаментальная технология, которая делает Интернет доступным и удобным для пользователей. Представьте себе, что DNS — это своего рода телефонная книга Интернета, которая позволяет вам находить веб-сайты и другие ресурсы по удобным для запоминания именам, а не по сложным числовым адресам. Давайте рассмотрим, почему DNS так важен и как он работает, с помощью интересных аналогий и примеров.

### Почему DNS так важен?
1. Удобство для пользователей:
   - Представьте, что вместо ввода www.example.com вам нужно запомнить и вводить что-то вроде 93.184.216.34. Это было бы очень неудобно и затруднительно. DNS позволяет использовать легко запоминающиеся доменные имена, что делает навигацию по Интернету гораздо проще.
2. Гибкость и управление:
   - DNS позволяет владельцам веб-сайтов и других онлайн-ресурсов легко управлять своими доменными именами и IP-адресами. Например, если ваш веб-сайт переезжает на новый сервер с другим IP-адресом, вам нужно просто обновить записи DNS, и пользователи будут автоматически перенаправлены на новый сервер.
3. Распределение нагрузки и отказоустойчивость:
   - DNS может направлять трафик на разные серверы в зависимости от географического положения пользователя или текущей нагрузки на серверы. Это помогает распределить нагрузку и обеспечить высокую доступность веб-сайтов и других онлайн-сервисов.
4. Безопасность:
   - DNSSEC (DNS Security Extensions) добавляет уровень безопасности, защищая DNS-запросы от подделки и других атак. Это помогает предотвратить перенаправление пользователей на поддельные веб-сайты.
   - 
### Как работает DNS?
Представьте, что вы хотите посетить веб-сайт www.example.com. Вот что происходит за кулисами:
1. Запрос к рекурсивному DNS-серверу:
   - Ваш браузер отправляет запрос к рекурсивному DNS-серверу, который обычно предоставляется вашим интернет-провайдером или настроен в вашей операционной системе.
2. Запрос к корневому DNS-серверу:
   - Если рекурсивный DNS-сервер не знает IP-адреса для www.example.com, он отправляет запрос к корневому DNS-серверу. Корневой сервер отвечает, что за доменом .com отвечает TLD-сервер.
3. Запрос к TLD-серверу:
   - Рекурсивный DNS-сервер отправляет запрос к TLD-серверу для домена .com. TLD-сервер отвечает, что за доменом example.com отвечает авторитетный DNS-сервер.
4. Запрос к авторитетному DNS-серверу:
   - Рекурсивный DNS-сервер отправляет запрос к авторитетному DNS-серверу для домена example.com. Авторитетный сервер отвечает IP-адресом для www.example.com.
5. Ответ пользователю:
   - Рекурсивный DNS-сервер возвращает IP-адрес вашему браузеру, и браузер устанавливает соединение с веб-сервером по этому IP-адресу.
   - 
### Интересные факты о DNS
- История DNS:
  - DNS был разработан в 1980-х годах, когда Интернет только начинал развиваться. До этого использовался файл hosts, который содержал список всех доменных имен и соответствующих им IP-адресов. По мере роста Интернета этот подход стал неэффективным, и была разработана распределенная система DNS.
- Корневые DNS-серверы:
  - В мире существует всего 13 корневых DNS-серверов, которые управляют корневой зоной DNS. Эти серверы распределены по всему миру и обеспечивают высокую доступность и отказоустойчивость.
- DNS-кэширование:
  - Рекурсивные DNS-серверы кэшируют ответы на запросы, чтобы ускорить последующие запросы. Это снижает нагрузку на авторитетные серверы и улучшает производительность.
- DNS-атаки:
  - DNS может быть уязвим для различных атак, таких как DNS-спуфинг (подделка DNS-ответов) и DDoS-атаки (распределенные атаки типа "отказ в обслуживании"). Для защиты от таких атак используются технологии, такие как DNSSEC и Anycast.
DNS — это невидимый герой Интернета, который работает в фоновом режиме, обеспечивая надежное и удобное преобразование доменных имен в IP-адреса. Без DNS Интернет был бы гораздо менее удобным и доступным для пользователей.

**commit: `lesson_62: информация о DNS`**

Docker — это платформа для разработки, доставки и эксплуатации приложений, которая использует контейнеризацию для упрощения процесса управления приложениями и их зависимостями. Концепция контейнеризации позволяет упаковывать приложения и их зависимости в изолированные контейнеры, которые могут быть легко перемещены и запущены на любом сервере или в любой среде.

### Что такое Docker?
Docker — это инструмент, который позволяет создавать, развертывать и управлять контейнерами. Он предоставляет API и интерфейс командной строки для управления контейнерами, а также экосистему инструментов и сервисов для упрощения работы с контейнерами.

### Основные компоненты Docker
1. Docker Engine:
   - Основной компонент Docker, который управляет контейнерами. Docker Engine включает в себя Docker Daemon (демон Docker), который выполняет основные операции, такие как создание и управление контейнерами.
2. Docker CLI (Command Line Interface):
   - Интерфейс командной строки для взаимодействия с Docker Engine. Позволяет пользователям выполнять команды для создания, запуска, остановки и управления контейнерами.
3. Docker Hub:
   - Облачный реестр, который хранит и распространяет Docker-образы. Docker Hub позволяет пользователям находить, загружать и публиковать Docker-образы.
4. Docker Compose:
   - Инструмент для определения и запуска многоконтейнерных Docker-приложений. Docker Compose использует YAML-файлы для описания конфигурации приложений и их зависимостей.
5. Docker Swarm:
   - Встроенный инструмент для оркестрации контейнеров, который позволяет создавать и управлять кластерами Docker-контейнеров.

### Концепция контейнеризации
Контейнеризация — это метод виртуализации на уровне операционной системы, который позволяет запускать и изолировать приложения и их зависимости в контейнерах. Контейнеры обеспечивают изоляцию, но используют общий ядро операционной системы, что делает их более легковесными по сравнению с виртуальными машинами.

### Основные преимущества контейнеризации
1. Изоляция:
   - Контейнеры изолируют приложения и их зависимости друг от друга, что позволяет избежать конфликтов и проблем с совместимостью.
2. Портативность:
   - Контейнеры могут быть перемещены и запущены на любом сервере или в любой среде, где установлен Docker. Это упрощает процесс развертывания и миграции приложений.
3. Легковесность:
   - Контейнеры используют общий ядро операционной системы, что делает их более легковесными по сравнению с виртуальными машинами. Это позволяет запускать больше контейнеров на одном сервере.
4. Скорость:
   - Контейнеры запускаются быстрее, чем виртуальные машины, так как они не требуют загрузки полной операционной системы.
5. Упрощение разработки и тестирования:
   - Контейнеры позволяют разработчикам создавать и тестировать приложения в изолированных средах, что упрощает процесс разработки и тестирования.
   - 
### Пример использования Docker
Предположим, что у вас есть веб-приложение, которое требует веб-сервер (например, Nginx), базу данных (например, MySQL) и приложение на Python. Вы можете использовать Docker для создания контейнеров для каждого из этих компонентов и управлять ими с помощью Docker Compose.
1. Создание Docker-образов:
   - Создайте Dockerfile для каждого компонента вашего приложения. Dockerfile описывает, как создать Docker-образ для конкретного компонента.
2. Создание Docker Compose файла:
   - Создайте файл docker-compose.yml, который описывает конфигурацию вашего приложения и его зависимостей.
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: example
  app:
    build: ./app
    depends_on:
      - db
3. Запуск приложения:
   - Используйте команду docker-compose up для запуска вашего приложения и его зависимостей.

**commit: `lesson_62: информация о Docker`**

**commit: `lesson_62: перенесли DEBUG в .env`**


## Lesson 63

1. Настройка `DEBUG` в `settings.py` для отладочного режима. Чтобы на сервере не отображались отладочные сообщения, установите `DEBUG = False` и добавьте домен сервера в список `ALLOWED_HOSTS`.
```python
DEBUG = os.getenv('DEBUG')
```

2. Настройка `ALLOWED_HOSTS` в `settings.py` для домена cardslurm.ru.
ALLOWED_HOSTS - это список хостов, которые могут обращаться к нашему сайту
```python
ALLOWED_HOSTS = ['cardslurm.ru', 'www.cardslurm.ru', 'localhost', '127.0.0.1']
```

3. Настройка `CSRF_TRUSTED_ORIGINS` в `settings.py` для безопасной работы с формами.
```python
CSRF_TRUSTED_ORIGINS - это список доменов, с которых можно отправлять POST-запросы без токена CSRF
CSRF_TRUSTED_ORIGINS = ['https://cardslurm.ru', 'https://www.cardslurm.ru']
```

4. Добавление `if DEBUG` для отладочной панели Django.
`INTERNAL_IPS`  - это список IP-адресов, с которых можно получить доступ к отладочной панели Django
if DEBUG:    
    INTERNAL_IPS = [
        '127.0.0.1',
    ]

**commit: `lesson_63: дополнительная настройка для работы проекта`**

```bash
python3 manage.py migrate && echo "from django.contrib.auth import get_user_model; User = get_user_model(); User.objects.create_superuser('admin', 'ad@ad.com', '12345')" | python3 manage.py shell && python3 manage.py loaddata dump.json
```

**commit: `lesson_63: команда для сборки проекта в timewebcloud`**

**commit: `lesson_63: FIX: ALLOWED_HOSTS`**

### Подготовка проекта к авторизации через соцсети

1. Устанавливаем библиотеку `social-auth-app-django` и добавляем ее в `requirements.txt`
https://python-social-auth.readthedocs.io/en/latest/index.html
`pip install social-auth-app-django`
`pip freeze > requirements.txt`

2. Добавляем приложение `social_django` в `INSTALLED_APPS` в `settings.py`
```python
INSTALLED_APPS = [
    ...
    'social_django',
]
```

3. Добавляем настройки `settings.py`
`AUTHENTICATION_BACKENDS` - список бэкендов аутентификации, для работы с соцсетями
`MIDDLEWARE` - список промежуточных слоев, для обработки исключений
`TEMPLATES` - список контекстных процессоров, для передачи данных в шаблоны
`SOCIAL_AUTH_URL_NAMESPACE` - пространство имен для URL-адресов авторизации
```python
AUTHENTICATION_BACKENDS = (
    'social_core.backends.github.GithubOAuth2',
    'social_core.backends.vk.VKOAuth2',
    'django.contrib.auth.backends.ModelBackend',
)
########
MIDDLEWARE = [
    ...
    'social_django.middleware.SocialAuthExceptionMiddleware',
]
########
TEMPLATES = [
    {
        ...
        'OPTIONS': {
            'context_processors': [
                ...
                'social_django.context_processors.backends',
                'social_django.context_processors.login_redirect',
            ],
        },
    },
]
SOCIAL_AUTH_URL_NAMESPACE = 'social'
```

4. Добавляем в `.env` и `env.example` переменные для авторизации через **GitHub** и **VK**
```python
GITHUB_KEY=None
GITHUB_SECRET=None
VK_KEY=None
VK_SECRET=None
```

5. Настройки в `settings.py` для авторизации через **GitHub** и **VK**
```python
SOCIAL_AUTH_URL_NAMESPACE = 'social'
SOCIAL_AUTH_GITHUB_KEY = os.getenv('GITHUB_KEY')
SOCIAL_AUTH_GITHUB_SECRET = os.getenv('GITHUB_SECRET')
SOCIAL_AUTH_VK_OAUTH2_KEY = os.getenv('VK_KEY')
SOCIAL_AUTH_VK_OAUTH2_SECRET = os.getenv('VK_SECRET')
LOGIN_REDIRECT_URL = '/users/profile/'
LOGOUT_REDIRECT_URL = '/'
```

6. Добавляем URL-адреса для авторизации через соцсети в `urls.py`
```python
from django.urls import include, path
urlpatterns = [
    ...
    path('social-auth/', include('social_django.urls', namespace='social')),
]
```

7. Добавляем в шаблон `profile.html` кнопки для авторизации через **GitHub** и **VK**
```html
<form method="post" action="{% url 'users:link_social_account' %}">
  {% csrf_token %}
  <button type="submit" name="provider" value="github" class="btn btn-dark">Привязать GitHub</button>
  <button type="submit" name="provider" value="vk-oauth2" class="btn btn-dark">Привязать VK</button>
</form>
```

8. Создаем представление для привязки соцсетей к пользователю в `views.py` приложения `users`
```python
from django.views import View
from django.shortcuts import redirect
from social_django.utils import psa

class SocialAuthView(View):

    @psa('social:complete')
    def save_oauth_data(self, request, backend):
        user = request.user
        if backend.name == 'github':
            user.github_id = backend.get_user_id(request)
        elif backend.name == 'vk-oauth2':
            user.vk_id = backend.get_user_id(request)
        user.save()
        return redirect('users:profile')

    def post(self, request, *args, **kwargs):
        if 'provider' in request.POST:
            provider = request.POST['provider']
            if provider == 'github':
                return redirect('social:begin', backend='github')
            elif provider == 'vk-oauth2':
                return redirect('social:begin', backend='vk-oauth2')
        return redirect('users:profile')
```

9. Добавление полей для хранения данных соцсетей в модель пользователя.
```python
class User(AbstractUser):
    ...
    github_id = models.CharField(max_length=255, blank=True, null=True)
    vk_id = models.CharField(max_length=255, blank=True, null=True)
```

10. Создание миграций и применение изменений в базе данных.
`python manage.py makemigrations`
`python manage.py migrate`

11. Добавление маршрутов для авторизации через соцсети в `urls.py` приложения `users`.
```python
from django.urls import path
from .views import SocialAuthView
urlpatterns = [
    ...
    path('link-social-account/', SocialAuthView.as_view(), name='link_social_account'),
    path('save-oauth-data/<str:backend>/', SocialAuthView.as_view(), name='save_oauth_data'),
]
```
12. Обновление шаблона `login.html`
```html
 <h3>Или зайдите через:</h3>
            <a href="{% url 'social:begin' 'vk-oauth2' %}" class="btn btn-dark">ВКонтакте</a>
            <a href="{% url 'social:begin' 'github' %}" class="btn btn-dark">GitHub</a>
```

**commit: `lesson_63: настройки приложения для авторизации через соцсети`**


## Lesson 64

### Lesson 64 - Разрешения и группы пользователей в Django
На данном этапе у нас есть кастомный User наследник AbstractUser, который содержит дополнительные поля для хранения данных пользователя. Мы добавили возможность авторизации через соцсети и привязку аккаунтов GitHub и VK к пользователю. 
Но мы не видем пользователей в админке, надо это исправить.
Нам нужно зарегистрировать модель в админке.
Создали `пользователя1` и `пользователя2`.
`Пользователь1` получил статус персонала.
После чего он смог попасть в админку, но не увидел ни одной модели.
Выдали ему право на просмотр модели пользователи, а так же карточки.
Теперь он их видет, но не может ничего сделать, в админке, даже изменить себе аватарку.
`Пользователь2` получил разерешние редактирования карточек.
Однако карточки редактировать по прежнему могут ВСЕ кто залогинен.
Попробуем это исправить.
Нам нужен новый миксин - `PermissionRequiredMixin`
Который проверяет права пользователя на выполнение действия.

```python
class EditCardUpdateView(MenuMixin, LoginRequiredMixin, PermissionRequiredMixin, UpdateView):
    model = Card  # Указываем модель, с которой работает представление
    form_class = CardForm  # Указываем класс формы для редактирования карточки
    template_name = 'cards/add_card.html'  # Указываем шаблон, который будет использоваться для отображения формы
    context_object_name = 'card'  # Имя переменной контекста для карточки
    success_url = reverse_lazy('catalog')  # URL для перенаправления после успешного редактирования карточки
    permission_required = 'cards.change_card'  # Указываем право, которое должен иметь пользователь для доступа к представлению
    # ТЕСТ - надо проверить))
    def has_permission(self):
        return self.request.user.is_staff or self.request.user == self.get_object().author
```
Теперь происходит проверка на права пользователя на редактирование карточки.
**АДМИН ИМЕЕТ ВСЕ ПРАВА!**
Добавим в `include` `card_preview.html` кнопку редактирования карточки
```html
{% if user.is_authenticated and user == card.author %}
    <a href="{% url 'edit_card' card.pk %}" class="btn btn-dark ms-3"><i class="bi bi-pencil-fill"></i></a>
{% endif %}
```

Альтернативный вариант. Залогиненные пользователи и те, у которых есть 
разрешение `cards.change_card`

```html
{% if user.is_authenticated and perms.cards.change_card %}
    <a href="{% url 'edit_card' card.pk %}" class="btn btn-dark ms-3"><i class="bi bi-pencil-fill"></i></a>
{% endif %}
```
**commit: `lesson_64: разрешение на обновление карточек`**

Создали группу модераторов и выдали им права на редактирование карточек.
В шаблон личного кабинете к модераторам добавили BS5 иконку ручки
<i class="bi bi-vector-pen"></i>
```html
{% if user.moderator %}
<i class="bi bi-vector-pen"></i>
{% endif %}
```
Далее, мы НЕ МОЖЕМ вызывать методы с аргументами в шаблонах.
Поэтому, нам надо каким-то образом передать, является ли пользователь модератором или нет в шаблон.
Лучший способ - контекстный процессор. 
Худший - бегать по вьюшкам и передавать это в каждую.
Мы не ищем легких путей

```python
def get_object(self, queryset=None):
        # Возвращает объект модели, который должен быть отредактирован
        # Проверят входит ли пользователь в группу "Модераторы",если да то user.moderator = True
        # Это самая убогая версия, но она работает))
        # Более качественный вариант - контекстный процессор! Он поместит эту проверку во все шаблоны
        user = self.request.user
        if user.groups.filter(name='Модераторы').exists():
            user.moderator = True
        return self.request.user
```

Модифицировали метод `get_object` в представлении для отображения личного кабинета.
И отрисовали ручку для модераторов в шаблоне личного кабинета.

**commit: `lesson_64: добавил иконку ручки для модераторов в админке (работа с шаблонами)`**

Создаем команду для создания группы модераторов и выдачи прав на редактирование карточек
Создаем для этого в приложении `users` пакет `management/commands` и в нем файл `create_moderators_group.py`

```python
from django.core.management.base import BaseCommand
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
from your_app_name.models import Card  # Замените 'your_app_name' на имя вашего приложения

class Command(BaseCommand):
    help = 'Создание группы Модераторы и назначение права change_card'
    def handle(self, *args, **kwargs):
        # Создаем или получаем группу "Модераторы"
        moderators_group, created = Group.objects.get_or_create(name='Модераторы')
        
        # Получаем контентный тип для модели Card
        content_type = ContentType.objects.get_for_model(Card)
        
        # Получаем разрешение change_card
        change_card_permission = Permission.objects.get(codename='change_card', content_type=content_type)
        
        # Добавляем разрешение группе "Модераторы"
        moderators_group.permissions.add(change_card_permission)
        
        if created:
            self.stdout.write(self.style.SUCCESS("Группа 'Модераторы' создана и права назначены!"))
        else:
            self.stdout.write(self.style.SUCCESS("Группа 'Модераторы' уже существует и права обновлены!"))
```

Модифицируем команду автодеплоя на севрере timeweb
```bash
python3 manage.py migrate && \
echo "from django.contrib.auth import get_user_model; User = get_user_model(); User.objects.create_superuser('admin', 'ad@ad.com', '12345')" | python3 manage.py shell && \
python3 manage.py loaddata dump.json && \
python3 manage.py create_moderators_group
```
Т.е. все что мы прописали в файле `create_moderators_group.py` будет выполнено при деплое на сервере
всего одной командой `python3 manage.py create_moderators_group` (по названию файла)

**commit: `lesson_64: создал команду для создания группы модераторов и выдачи прав на редактирование карточек`**

- в интерфейсе деплоя, в строке `Команда сборки` нужно написать команду `bash deploy.sh`
- 
**commit: `lesson_64: добавили скрипт для деплоя`**


## Lesson 65

`UserPassesTestMixin` - это миксин, который позволяет проверить, проходит ли пользователь тест, прежде чем получить доступ к представлению.
`test_func` - это метод, который определяет, проходит ли пользователь тест.
Добавим в представление для редактирования карточки проверку на то, является ли пользователь автором карточки.

```python
    # test_func - метод для миксина UserPassesTestMixin, который проверяет, что пользователь является автором карточки
    def test_func(self):
        card = self.get_object()
        user = self.request.user
        is_moderator = user.groups.filter(name='Модераторы').exists()
        is_administrator = user.is_superuser 
        # is_superuser - это булево поле, которое указывает, является ли пользователь суперпользователем
        # is_staff - это булево поле, которое указывает, имеет ли пользователь доступ к административной панели
        return user == card.author or is_moderator or is_administrator
        
```

<!-- Обновили логику в шаблоне card_preview.html -->
```html
{% if perms.cards.change_card or user == card.author %}
    <a href="{% url 'edit_card' card.pk %}" class="btn btn-dark ms-3"><i class="bi bi-pencil-fill"></i></a>
{% endif %}
```

**commit: `lesson_65: добавил проверку на авторство карточки в представление для редактирования карточки`**

Сигналы в **Django** — это мощный инструмент для создания гибких и расширяемых приложений. Они позволяют различным частям приложения уведомлять друг друга о происходящих событиях и выполнять определенные действия в ответ на эти события. Давайте рассмотрим сигналы более подробно.

#### Основные концепции
`Сигнал (Signal)`: Это объект, который отправляется для уведомления о происходящем событии. Сигналы могут быть встроенными (предоставляемыми **Django**) или пользовательскими (созданными вами).
`Отправитель (Sender)`: Это объект, который отправляет сигнал. Обычно это модель или класс, который выполняет определенное действие.
`Получатель (Receiver)`: Это функция, которая обрабатывает сигнал. Получатель подключается к сигналу и выполняет определенные действия в ответ на этот сигнал.

#### Встроенные сигналы
**Django** предоставляет множество встроенных сигналов, которые связаны с основными операциями моделей. Вот некоторые из них:
`pre_save`: Отправляется перед сохранением объекта модели.
`post_save`: Отправляется после сохранения объекта модели.
`pre_delete`: Отправляется перед удалением объекта модели.
`post_delete`: Отправляется после удаления объекта модели.
`m2m_changed`: Отправляется при изменении связи "многие ко многим".

- Создали телеграм бота
- Создали сигнал
- Подключили сигнал
- Модифицировали настройки (переменные для бота)
- Модифицировали файл `.env` и `.env.example`

**commit: `lesson_65: создал телеграм бота и подключил сигнал`**